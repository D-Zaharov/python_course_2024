# Домашняя работа 6

**дедлайн 22.10.2024 23:59**

## Задание 1

Необходимо создать систему на основе ООП для применения в любой интересной сфере и написать отчет о ее функциональности.

- в системе должно быть не менее 5 классов
- система должна реализовывать наследование, инкапсуляцию и полиморфизм
- у каждого класса должно быть не менее трех свойств и не менее двух методов  (включая родительские)
- необходимо написать не только классы, но и скрипт, илюстрирующий работу системы
- в отчете должно быть описание системы, для чего она может применяться, описание классов, их свойств и методов и краткое описание работы тестового скрипта.

### пример задания, по которому можно написать систему:

Необходимо создать программную систему для управления бронированием номеров в отеле.

### Требования к системе:

1. **Классы:**

   - **`Номер`** (базовый класс):
     - Свойства: номер (`int`), тип номера (`string`), максимальное количество людей в номере, стоимость за сутки (`double`), доступность (`bool`).
     - Методы: `забронировать()`, `освободить()`.

   - **`Люкс`** (наследуется от `Номер`):
     - Дополнительные свойства: балкон (`bool`), мини-бар (`bool`).
     - Методы: переопределение `забронировать()` с дополнительной логикой для люкс-номеров (например дополнительные пожелания клиентов).

   - **`Стандарт`** (наследуется от `Номер`):
     - Дополнительные свойства: количество кроватей (`int`).
     - Методы: переопределение `освободить()` с дополнительной логикой для стандартных номеров.

   - **`Эконом`** (наследуется от `Стандарт`):
     - Методы: переопределение `освободить()` с рассчетом на то, что в номере могут быть несколько постояльцев, выезжающих в разное время, то есть номер может быть занят не полностью.

   - **`Гость`**:
     - Свойства: ФИО (`string`), номер телефона (`string`), идентификатор брони (`int`).
     - Методы: `забронироватьНомер(Nомер номер)`.

   - **`Отель`**:
     - Свойства: список номеров (`List<Номер>`).
     - Методы: `добавитьНомер(Номер номер)`, `найтиНомерПоНомеру(int номер)`, `всеСвободныеНомера()`, `найтиНомерНаКоличествоЧеловек()`.

2. **Функционал системы:**

   - Добавление номеров различных типов в отель.
   - Бронирование номеров гостями с проверкой доступности.
   - Освобождение номеров после окончания бронирования.
   - Поиск свободных номеров по типу или ценовому диапазону.

### Тестовый скрипт:

1. Создать экземпляры различных типов номеров и добавить их в отель.
2. Создать экземпляры гостей и выполнить их бронирование.
3. Проверить доступность номеров после бронирования.
4. Освободить забронированные номеры и проверить, стали ли они доступны.
5. Найти все свободные номера определенного типа, в заданном ценовом диапазоне, поиск свободных номеров для компании (максимальное число человек для размещения в номер больше либо равно максимальному кол-ву людей, могущих быть в номере).

## Задание 2

Необходимо реализовать структуру бинарного дерева поиска, методы для работы с ним и интерфейс пользователя cli (command line interface)

Ожидается, что у каждого листа дерева не может быть больше двух потомков и все значения в левом поддереве меньше, а все значения в правом поддереве больше узла. Хранить предполагается числовые данные.

### Структура одного узла
- value: Ключ со значением в узле
- left: ключ-ссылка на узел левого потомка
- right: ключ-ссылка на узел правого потомка
- parent:  ключ-ссылка на родительский узел

### Внутренние методы дерева:
- Создание нового узла
- Склейка веток при удалении узла


### Методы для работы с деревом
- Добавление элемента
- Удаление элемента
- Поиск элемента
- печать дерева на экран

## Задание 3 Дополнительно

### информация о нейросетях:

#### Что такое нейросеть?

Нейросеть — это математическая модель, вдохновленная работой человеческого мозга, предназначенная для распознавания паттернов и выполнения задач машинного обучения. Она состоит из множества взаимосвязанных узлов (нейронов), которые организованы в слои.

#### Основные компоненты нейросети

##### 1. **Слои (Layers)**
Слои являются основными строительными блоками нейросети:
- **Входной слой**: Получает исходные данные.
- **Скрытые слои**: Выполняют вычисления и извлекают полезные признаки из данных. В каждом слое нейроны соединены с нейронами предыдущего слоя.
- **Выходной слой**: Производит окончательное предсказание.

##### 2. **Функции активации (Activation Functions)**
Функции активации определяют, активируется ли нейрон на основе входных данных. Они добавляют нелинейность в модель, что позволяет решать сложные задачи.
- **ReLU (Rectified Linear Unit)**: Преобразует все отрицательные значения в ноль, а положительные оставляет без изменений. Часто используется в скрытых слоях.
- **Softmax**: Преобразует выходные значения в вероятности, сумма которых равна 1. Используется в выходных слоях для задач классификации.

##### 3. **Функции потерь (Loss Functions)**
Функции потерь оценивают, насколько предсказания модели отличаются от истинных значений. Чем меньше значение функции потерь, тем лучше модель.
- **Cross-Entropy Loss**: Часто используется для задач классификации (к примеру мы хотим определить, котик на фотографии или собачка). Она измеряет разницу между предсказанными вероятностями и реальными метками классов (котик, собачка, 0 или 1).
- **Mean Squared Error (MSE)**: Используется для задач регрессии (к примеру задача предсказания цены на что-либо, когда переменная, которую мы предсказываем может принимать множество различных значений). Измеряет среднеквадратичное отклонение предсказанных значений от истинных значений.

##### 4. **Оптимизаторы (Optimizers)**
Оптимизаторы обновляют параметры модели (веса и смещения) для минимизации функции потерь. Они определяют, как быстро и эффективно модель учится.
- **SGD (Stochastic Gradient Descent)**: Простейший оптимизатор, обновляющий параметры модели на каждом шаге на основе градиентов функции потерь.
- **Adam (Adaptive Moment Estimation)**: Более сложный оптимизатор, который адаптирует скорость обучения для каждого параметра, сочетая преимущества двух других методов: Adagrad и RMSProp.

#### Основные этапы работы с нейросетью в PyTorch

##### 1. Импорт библиотек
Для работы с нейросетями в PyTorch используются следующие модули:

###### 1. **torch**
Основной модуль PyTorch, предоставляющий функционал для работы с тензорами, которые являются основным типом данных в нейросетях. Он поддерживает множество операций над тензорами, включая линейную алгебру, матричные операции и математические функции.

###### 2. **torch.nn**
Модуль для создания и работы с нейросетями. Он включает в себя:
- **nn.Module**: Базовый класс для всех нейросетей. Позволяет определять слои и структуру сети.
- **nn.Linear**: Полносвязный (линейный) слой.
- **nn.ReLU**: Функция активации ReLU.
- **nn.CrossEntropyLoss**: Функция потерь для задач классификации.
- **nn.Softmax**: Функция активации softmax для преобразования выходных данных в вероятности.

###### 3. **torch.optim**
Модуль для работы с оптимизаторами. Обеспечивает методы для обновления параметров модели на основе вычисленных градиентов.
- **optim.SGD**: Оптимизатор стохастического градиентного спуска.
- **optim.Adam**: Адаптивный метод оптимизации моментов.

###### 4. **torch.utils.data**
Модуль для работы с датасетами и загрузчиками данных.
- **TensorDataset**: Класс для оборачивания тензоров в датасет, который PyTorch может использовать.
- **DataLoader**: Класс для создания итераторов данных, которые поддерживают пакетную обработку и перемешивание данных.

###### 5. **torch.nn.functional (F)**
Модуль, предоставляющий функциональные интерфейсы для различных операций, таких как функции активации, потери и другие вспомогательные функции, которые можно использовать напрямую в методе `forward`.

##### 2. Определение архитектуры модели
В PyTorch нейросети определяются с помощью классов, которые наследуются от torch.nn.Module. В конструкторе класса определяются слои сети, а в методе forward задается, как данные проходят через слои (т.е. вперед по сети).

##### 3. Создание датасетов и загрузчиков данных
- **TensorDataset**: Используется для обертывания входных данных и меток в тензоры, которые PyTorch может использовать.
- **DataLoader**: Помогает разбить данные на мини-пакеты, управлять очередностью данных (например, перемешивание) и загружать данные параллельно.

##### 4. Компиляция и обучение модели
- **Функция потерь (loss function)**: Определяет, насколько хорошо или плохо работает модель, например, `nn.CrossEntropyLoss` для задачи классификации.
- **Оптимизатор (optimizer)**: Метод, который обновляет параметры модели на основе градиентов, например, `optim.Adam`.

##### 5. Тренировочный цикл
Во время обучения:
- Модель переводится в режим обучения с помощью `model.train()`.
- Для каждого мини-пакета данных:
  - Выполняется прямой проход (forward pass) для вычисления предсказаний.
  - Вычисляется ошибка с использованием функции потерь.
  - Выполняется обратный проход (backward pass) для вычисления градиентов.
  - Оптимизатор обновляет параметры модели.
- После каждой эпохи (полного прохода по данным) вычисляется и отображается средняя ошибка и точность.

##### 6. Оценка модели на тестовых данных
- Модель переводится в режим оценки с помощью `model.eval()`.
- Используется `torch.no_grad()`, чтобы отключить вычисление градиентов, что экономит память и ускоряет вычисления.
- Выполняется прямой проход по тестовым данным, вычисляется ошибка и точность модели.

##### 7. Предсказание для одного примера
- Для предсказания одного примера данных используется метод `model.eval()` и `torch.no_grad()`.
- Входные данные конвертируются в тензор и передаются модели.
- Результаты предсказания извлекаются и интерпретируются.

### Основные метрики для оценки модели

#### 1. **Точность (Accuracy)**
Точность измеряет долю правильных предсказаний модели из общего числа предсказаний. Используется в задачах классификации.

#### 2. **Ошибка (Loss)**
Ошибка (или функция потерь) измеряет разницу между предсказанными значениями и истинными значениями. Используется для настройки и оптимизации модели.

#### 3. **Точность (Precision)**
Точность определяет долю правильно предсказанных положительных классов из всех предсказанных положительных классов. Важна в задачах, где важно минимизировать ложноположительные результаты.

#### 4. **Полнота (Recall)**
Полнота измеряет долю правильно предсказанных положительных классов из всех реальных положительных классов. Важна в задачах, где важно минимизировать ложноотрицательные результаты.

#### 5. **F-мера (F1 Score)**
F-мера является гармоническим средним точности и полноты. Используется для балансировки между точностью и полнотой, особенно при несбалансированных данных.

#### 6. **Среднеквадратичная ошибка (Mean Squared Error, MSE)**
MSE измеряет среднеквадратичное отклонение предсказанных значений от истинных значений. Используется в задачах регрессии.

#### 7. **Корень среднеквадратичной ошибки (Root Mean Squared Error, RMSE)**
RMSE является квадратным корнем из MSE и интерпретируется в тех же единицах, что и исходные данные. Используется в задачах регрессии.

#### 8. **Средняя абсолютная ошибка (Mean Absolute Error, MAE)**
MAE измеряет среднюю абсолютную разницу между предсказанными значениями и истинными значениями. Используется в задачах регрессии.

#### 9. **Коэффициент детерминации (R²)**
R² измеряет долю дисперсии зависимой переменной, объясняемой моделью. Используется в задачах регрессии для оценки качества предсказаний модели.

### Важные концепты
- **Режимы модели**: Использование `model.train()` для обучения и `model.eval()` для оценки обеспечивает корректное поведение модели.
- **Мини-пакеты (mini-batches)**: Использование небольших пакетов данных для обучения модели делает процесс более эффективным и позволяет использовать большие датасеты.
- **Градиенты и обратное распространение (backpropagation)**: Метод, используемый для минимизации функции потерь путем корректировки параметров модели.
- **Отключение градиентов**: `torch.no_grad()` отключает вычисление градиентов для повышения производительности при оценке и предсказании.


### задание

Взяв файл `data.csv` из архива `music.zip` необходимо построить нейронную сеть, классифицирующую дорожки по жанрам музыки. Имеем задачу классификации (всего 10 классов, можно видеть, проанализировав столбец label).

* необходимо использовать библиотеки pytorch, pandas и sklearn.
* Из исходного файла необходимо удалить столбец с названием дорожки (filename) и выделить столбец label в отдельную переменную.
* необходимо закодировать названия жанров в числами (используем LabelEncoder sklearn)
* нормируем оставшиеся признаки (используем StandardScaler())
* разбиваем файл на тренировочную и тестовые выборки (берем 80% на обучение и 20% на тесты, используем train_test_split sklearn)
* преобразуем тренировочные и тестовые данные в формат, необходимый для torch. Используем TensorDataset, torch.tensor и DataLoader
* нейронную сеть необходимо оформить в виде класса. В качестве слоев используем простые линейные слои (torch.nn.Linear). Строим пирамидальную архитектуру: исходно 256 нейронов, далее 128 и так по степенидвойки до 16, далее будет выходной слой с 10 нейронами (10 жанров музыки). В качестве функции активации используем relu. В качестве последней функции - softmax. Фактически класс будет иметь два метода
__init__(self, input_size, num_classes), где будут описаны слои нейросети
forward(self, x), где будут описаны функции активации

* в качестве функции потерь используем nn.CrossEntropyLoss. в качестве оптимизатора - optim.Adam
* Тренируем модель (достаточно 20 эпох обучения). Смотрим, как меняется точность модели и ее функция потерь.
* Проверяем предсказания модели на тестовой выборке, считаем точность
* берем первый элемент из тестовой выборки и смотрим на предсказание модели. Сравниваем, насколько она права.